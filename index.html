<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link type="text/css" href="styles.css?v=20251215" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/v/dt/dt-1.13.1/datatables.min.css"/>
    <link href="dist/sp-bootstrap.min.css" rel="stylesheet" media="screen">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <title>Sort Your Music</title>
</head>
  <body>
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            <span class="navbar-logo"></span>
            <span class="navbar-title">Sort Your Music</span>
          </a>
        </div>
        <div class="navbar-collapse collapse">
          <a href="https://www.spotify.com" class="btn btn-primary navbar-btn navbar-right">Get Spotify</a>
        </div><!--/.navbar-collapse -->
      </div>
    </div>

    <div id="intro">
      <div id="main" class="top worker jumbotron jumbotron-hero container-fluid">
          <div id="jumbo-dialog">
            <h1 id="ttitle">Sort Your Music</h1>
            <p id="ttext">
                Sort your Spotify playlists by any of
                a wide range of musical attributes such as tempo, loudness,
                valence, energy, danceability, popularity and more. Now with
                <b>Filters</b>!
            </p>
            <p>Login with your Spotify account to get started</p>
            <p><a class="btn btn-primary btn-lg" id="go" role="button">Login with Spotify</a></p>
          </div>
      </div>

      <div class="container worker">
        <div class="row features">
          <div class="col-md-offset-2 col-md-8">
            <h2 class="text-center">Get your playlists in order</h2>
            <p>
              With <b>Sort Your Playlists</b> you can easily order the songs
              in any of your playlists by a wide range of parameters. Just
              follow these steps:
            </p>
            <ol>
              <li><b>Login</b> with your Spotify credentials</li>
              <li><b>Pick</b> your playlist</li>
              <li><b>Sort</b> the playlist by clicking on the column headings in the playlist table</li>
              <li><b>Save</b> the sorted playlist to Spotify</li>
            </ol>

            <h2 class="text-center">Tap into the power of Spotify's song attributes</h2>
            <p>
              <b>Sort Your Music</b> lets you sort your playlist based on a number of Spotify's song attributes including:
            </p>

            <ol>
              <li><b>Beats Per Minute (BPM)</b> - The tempo of the song.</li>
              <li><b>Energy</b> - The energy of a song - the higher the value, the more energetic.</li>
              <li><b>Danceability</b> - The higher the value, the easier it is to dance to this song.</li>
              <li><b>Loudness</b> - The higher the value, the louder the song.</li>
              <li><b>Valence</b> - The higher the value, the more positive mood for the song.</li>
              <li><b>Length</b> - The duration of the song.</li>
              <li><b>Acoustic</b> - The higher the value the more acoustic the song is.</li>
              <li><b>Popularity</b> - The higher the value the more popular the song is.</li>
              <li><b>A.Sep</b> - maximizes the artist separation in the set.</li>
              <li><b>Rnd</b> - A random number. Sort by this column to shuffle your playlist.</li>
            </ol>

            <h2 class="text-center">FAQ</h2>
            <p>Here are some answers to questions about <b>Sort Your Music</b></p>
            <ol>
              <li><b>How was this built?</b> This was created using the <a href="https://developer.spotify.com">Spotify</a> API.</li>
              <li><b>Where can I learn more about the Spotify song attributes?</b> See <a href="https://developer.spotify.com/documentation/web-api/reference/#/operations/get-audio-analysis">Acoustic Attributes Overview</a></li>
              <li><b>Can you add more attributes to the app?</b> Yes, but it is a tradeoff between display space, complexity and utility.</li>
              <li><b>Any more features planned?</b> Yes, I'd like to add: duplicate track removal; manual reordering/addition/deletion.</li>
              <li><b>Is the source available</b> Yes, on <a href="https://github.com/plamere/SortYourMusic">GitHub</a></li>
              <li><b>Does Sort Your Music overwrite my playlist when I save?</b> Only if you choose 'Overwrite playlist'; otherwise it creates a copy.</li>
            </ol>
          </div>
        </div>
      </div>

      <div class="top jumbotron container-fluid">
        <p id="info" class="text-center"></p>

        <div class="worker" id="playlists">
          <h2 class="prompt">Pick a playlist:</h2>
          <img class="spinner" width="100" alt="spinner" src="images/ajaxSpinner.gif">

          <div class="panel panel-default">
            <table id="playlist-list" class="table">
              <thead>
                <tr>
                  <th>Cover</th>
                  <th>Name</th>
                  <th>Track Count</th>
                  <th>Owner</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

        <div class="worker" id="single-playlist">
          <h2><a id="playlist-title"></a></h2>
          <img class="spinner2" width="100" alt="spinner" src="images/ajaxSpinner.gif">
          <div id="single-playlist-contents">

            <div class="panel panel-default">
              <div class="panel-body">

                <div class="btn-group pull-right">
                  <button id="save" type="button" class="btn btn-primary btn-sm has-spinner"><i class="fa fa-spinner fa-spin"></i> Save New Playlist</button>
                  <button id="saveDropdown" type="button" class="btn btn-primary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    <span class="caret"></span>
                    <span class="sr-only">Toggle Dropdown</span>
                  </button>
                  <ul class="dropdown-menu">
                    <li><a id="dropSave" href="#">Save New Playlist</a></li>
                    <li><a id="dropOverwrite" href="#">Overwrite Playlist</a></li>
                  </ul>
                </div>

                <a class="btn btn-primary btn-sm pull-left" id="pick" role="button">back</a>
              </div>
            </div>

            <div class="panel panel-default">
              <div class="panel-body">
                <div class="form-inline">
                  <div class="form-group">
                    <label for="min-bpm">BPM Filter Minimum:</label>
                    <input id="min-bpm" type="number" class="form-control" placeholder="0">
                  </div>
                  <div class="form-group">
                    <label for="max-bpm">Maximum:</label>
                    <input id="max-bpm" type="number" class="form-control" placeholder="1000">
                  </div>
                  <div class="form-group">
                    <label for="include-double">Include doubled BPM</label>
                    <input id="include-double" type="checkbox" checked="checked">
                  </div>
                </div>
              </div>
            </div>

            <table id="song-table" class="display stripe compact cell-border">
              <thead>
                <tr>
                  <th title="original track order">#</th>
                  <th title="the title of the track">Title</th>
                  <th title="the primary artist of the track">Artist</th>
                  <th title="date of release">Release</th>
                  <th title="the tempo, in beats-per-minute of the track">BPM</th>
                  <th title="the overall energy of the track">Energy</th>
                  <th title="the danceability of the track">Dance</th>
                  <th title="the loudness in dBs of the track">Loud</th>
                  <th title="how positive is the track">Valence</th>
                  <th title="the duration of the track">Length</th>
                  <th title="how acoustic is the track">Acoustic</th>
                  <th title="how popular is the track">Pop.</th>
                  <th title="maximizes artist separation">A.Sep</th>
                  <th title="a random value, suitable for generating a random shuffle">Rnd</th>
                </tr>
              </thead>
              <tbody></tbody>
              <tfoot></tfoot>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div id="footer">
      <div class="container text-center">
        <p class="text-muted">
          Powered by <a href="https://spotify.com">Spotify</a>
          Created by <a href="https://twitter.com/plamere">@plamere</a>
          with contributions by <a href="https://twitter.com/sonneveld">@sonneveld</a>.
        </p>
      </div>
    </div>

    <!-- Libraries (UPDATED: jQuery 3.7.1, removed Q) -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

    <script type="text/javascript" src="https://cdn.datatables.net/v/dt/dt-1.13.1/datatables.min.js"></script>
    <script type="text/javascript" charset="utf-8" src="https://cdn.datatables.net/plug-ins/1.10.7/sorting/time.js"></script>

    <script src="lib/bootstrap.min.js"></script>
    <script src="lib/underscore-min.js"></script>

    <!-- Your config MUST define: SPOTIFY_CLIENT_ID, SPOTIFY_REDIRECT_URI -->
    <script src="config.js?v=20251215"></script>

<script>
"use strict";

var accessToken = null;
var curUserID = null;
var curPlaylist = null;
var albumDates = {};
var audio = $("<audio>");
var songTable;
var cols = [
    'order', 'title', 'artist', 'Date', 'BPM', 'energy',
    'danceability', 'loudness', 'valence', 'duration',
    'acousticness', 'popularity', 'artist separation', 'rnd'
];

var forceDisableSave = false;
var savedState = {};

function error(msg) {
    info(msg);
    if (msg !== "") alert(msg);
}

function info(msg) {
    $("#info").text(msg);
}

function getCurSortName() {
    let currentState = getPlaylistState();
    let col = currentState.order[0];
    if (directionMatters(col)) {
        let prefix = (currentState.order[1] == 'asc') ? 'increasing ' : 'decreasing ';
        return prefix + cols[col];
    } else {
        return cols[col];
    }
}

function directionMatters(col) {
    let cname = cols[col];
    return !(cname === "rnd" || cname === "artist separation");
}

function base64urlencode(a) {
    return btoa(String.fromCharCode.apply(null, new Uint8Array(a)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

function generateCodeVerifier() {
    const array = new Uint8Array(64);
    window.crypto.getRandomValues(array);
    return base64urlencode(array);
}

async function generateCodeChallenge(code_verifier) {
    const encoder = new TextEncoder();
    const data = encoder.encode(code_verifier);
    const digest = await window.crypto.subtle.digest('SHA-256', data);
    return base64urlencode(digest);
}

async function authorizeUser() {
    if (typeof SPOTIFY_CLIENT_ID === 'undefined' || !SPOTIFY_CLIENT_ID) {
        error("SPOTIFY_CLIENT_ID is not set. Please set it in config.js.");
        return;
    }
    if (typeof SPOTIFY_REDIRECT_URI === 'undefined' || !SPOTIFY_REDIRECT_URI) {
        error("SPOTIFY_REDIRECT_URI is not set. Please set it in config.js.");
        return;
    }

    var scopes = 'playlist-read-private playlist-modify-private playlist-modify-public';

    const code_verifier = generateCodeVerifier();
    const code_challenge = await generateCodeChallenge(code_verifier);

    localStorage.setItem('spotify_code_verifier', code_verifier);

    var url = 'https://accounts.spotify.com/authorize' +
        '?client_id=' + encodeURIComponent(SPOTIFY_CLIENT_ID) +
        '&response_type=code' +
        '&redirect_uri=' + encodeURIComponent(SPOTIFY_REDIRECT_URI) +
        '&scope=' + encodeURIComponent(scopes) +
        '&code_challenge_method=S256' +
        '&code_challenge=' + encodeURIComponent(code_challenge);

    console.log("AUTHORIZE URL:", url);
    document.location = url;
}

async function exchangeCodeForToken(code) {
    const code_verifier = localStorage.getItem('spotify_code_verifier');
    if (!code_verifier) {
        error("Missing PKCE code_verifier.");
        return;
    }

    const params = new URLSearchParams();
    params.append('client_id', SPOTIFY_CLIENT_ID);
    params.append('grant_type', 'authorization_code');
    params.append('code', code);
    params.append('redirect_uri', SPOTIFY_REDIRECT_URI);
    params.append('code_verifier', code_verifier);

    const response = await fetch('https://accounts.spotify.com/api/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: params.toString()
    });

    const data = await response.json();
    if (!response.ok) {
        throw new Error((data && data.error_description) ? data.error_description : "Failed to exchange code for token");
    }

    accessToken = data.access_token;
    localStorage.removeItem('spotify_code_verifier');
}

function parseArgs() {
    let args = {};
    function parse(str) {
        str.split('&').forEach(function(kv) {
            if (!kv) return;
            let [k, v] = kv.split('=');
            if (k) args[decodeURIComponent(k)] = decodeURIComponent(v || '');
        });
    }
    let query = location.search.substring(1);
    let hash = location.hash.replace(/^#/, '');
    if (query) parse(query);
    if (hash) parse(hash);
    return args;
}

function callSpotify(type, url, json, callback) {
    $.ajax(url, {
        type: type,
        data: JSON.stringify(json),
        dataType: 'json',
        headers: {
            'Authorization': 'Bearer ' + accessToken,
            'Content-Type': 'application/json'
        },
        success: function(r) { callback(true, r); },
        error: function(r) {
            if (r.status >= 200 && r.status < 300) callback(true, r);
            else callback(false, r);
        }
    });
}

function callSpotifyP(type, url, json) {
    return new Promise(function(resolve, reject) {
        $.ajax(url, {
            type: type,
            data: JSON.stringify(json),
            dataType: 'json',
            headers: {
                'Authorization': 'Bearer ' + accessToken,
                'Content-Type': 'application/json'
            },
            beforeSend: function () { console.log(type + ": " + this.url); },
            success: function(data) { resolve(data); },
            error: function(jqXHR, textStatus) {
                const status = (jqXHR && typeof jqXHR.status === 'number') ? jqXHR.status : 'unknown';
                const body = (jqXHR && jqXHR.responseText) ? jqXHR.responseText : '';
                reject(`HTTP ${status} ${textStatus}${body ? " — " + body : ""}`);
            }
        });
    });
}

function getSpotify(url, data, callback) {
    $.ajax(url, {
        dataType: 'json',
        data: data,
        headers: { 'Authorization': 'Bearer ' + accessToken },
        success: function(r) { callback(r); },
        error: function() { callback(null); }
    });
}

function getSpotifyP(url, data) {
    return new Promise(function(resolve, reject) {
        $.ajax(url, {
            dataType: 'json',
            data: data,
            headers: { 'Authorization': 'Bearer ' + accessToken },
            success: function(data) { resolve(data); },
            error: function(jqXHR, textStatus) {
                // Provide useful debug info instead of just "error"
                const status = (jqXHR && typeof jqXHR.status === 'number') ? jqXHR.status : 'unknown';
                const body = (jqXHR && jqXHR.responseText) ? jqXHR.responseText : '';
                reject(`HTTP ${status} ${textStatus}${body ? " — " + body : ""}`);
            }
        });
    });
}

function showPlaylists() {
    $(".worker").hide();
    $("#playlists").show();
}

function fetchCurrentUserProfile(callback) {
    var url = 'https://api.spotify.com/v1/me';
    getSpotify(url, null, callback);
}

function fetchPlaylists(uid, callback) {
    $("#playlist-list tbody").empty();
    $(".prompt").hide();
    $(".spinner").show();

    info("Getting your playlists");
    var url = 'https://api.spotify.com/v1/me/playlists';
    var data = { limit:50, offset:0 };
    getSpotify(url, data, callback);
}

function goodPlaylist(playlist) {
    return playlist.tracks.total > 0;
}

function formatOwner(owner) {
    if (owner.id == curUserID) return "";
    return owner.id;
}

function get_tiny_image(playlist) {
    if (playlist.images) {
        var len = playlist.images.length;
        if (len > 0) return playlist.images[len - 1]['url'];
    }
    return null;
}

function playlistLoaded(playlists) {
    var pl = $("#playlist-list tbody");
    $(".prompt").show();
    $(".spinner").hide();
    if (playlists) {
        info("");
        _.each(playlists.items, function(playlist) {
            if (goodPlaylist(playlist)) {
                var tr = $("<tr>");
                var tiny_image_url = get_tiny_image(playlist);
                var imageCell = $("<td>");
                if (tiny_image_url) {
                    var image = $("<img>");
                    image.attr("src", tiny_image_url);
                    image.attr("width", "60px");
                    imageCell.append(image);
                }
                tr.append(imageCell);

                var tdName = $("<td>");
                var aName = $("<a>")
                    .text(playlist.name)
                    .addClass('hoverable')
                    .on('click', function() { fetchSinglePlaylist(playlist); });
                tdName.append(aName);

                var tdTrackCount = $("<td>").text(playlist.tracks.total);
                var tdOwner = $("<td>").text(formatOwner(playlist.owner));

                tr.append(tdName);
                tr.append(tdTrackCount);
                tr.append(tdOwner);
                pl.append(tr);
            }
        });
        if (playlists.next) getSpotify(playlists.next, null, playlistLoaded);
    } else {
        error("Sorry, I couldn't find your playlists");
    }
}

function loadPlaylists(uid) {
    $("#playlists").show();
    fetchPlaylists(uid, playlistLoaded);
}

function inRange(val, min, max) {
    return ( ( isNaN(min) && isNaN(max) ) ||
             ( isNaN(min) && val <= max ) ||
             ( min <= val && isNaN(max) ) ||
             ( min <= val && val <= max ) );
}

function playlistFilter(settings, data) {
    var minBpm = parseInt($('#min-bpm').val(), 10);
    var maxBpm = parseInt($('#max-bpm').val(), 10);
    var includeDouble = $('#include-double').is(':checked');
    var bpm = parseFloat(data[4]) || 0;

    return inRange(bpm, minBpm, maxBpm) ||
        (includeDouble && inRange(bpm*2, minBpm, maxBpm));
}

function playTrack(track) {
    audio.attr('src', track.preview_url);
    audio.get(0).play();
}

function stopTrack() {
    audio.get(0).pause();
}

// ------------------------- Playlist Loading -------------------------

function fetchAudioFeatures(ids) {
    var cids = ids.join(',');
    var url = "https://api.spotify.com/v1/audio-features";
    return getSpotifyP(url, { ids: cids });
}

function fetchAlbums(ids) {
    var cids = ids.join(',');
    var url = "https://api.spotify.com/v1/albums";
    return getSpotifyP(url, { ids: cids });
}

function fetchAllAlbums(ids) {
    var maxAlbumsPerCall = 20;
    var ps = [];
    for (var i = 0; i < ids.length; i += maxAlbumsPerCall) {
        var aids = ids.slice(i, i + maxAlbumsPerCall);
        ps.push(fetchAlbums(aids));
    }
    return Promise.all(ps);
}

function clearTable() {
    songTable.clear();
}

function updateTable(items) {
    $("#single-playlist-contents").show();
    _.each(items, function(item) {
        if (item.track) {
            var track = item.track;
            track.rnd = Math.random() * 10000;
            addTrack(songTable, track);
        }
    });
    songTable.draw();
    $(".spinner2").hide();
}

function formatDuration(dur) {
    var mins = Math.floor(dur / 60);
    var secs = Math.floor(dur - mins * 60);
    var ssecs = secs.toString();
    if (secs < 10) ssecs = '0' + ssecs;
    return mins + ":" + ssecs;
}

function addTrack(table, track) {
    if (track && track.enInfo && 'tempo' in track.enInfo) {
        var relDate = '';
        if (track.album.id in albumDates) relDate = albumDates[track.album.id];
        table.row.add([
            track.which + 1,
            track.name,
            track.artists[0].name,
            relDate,
            Math.round(track.enInfo.tempo),
            Math.round(track.enInfo.energy * 100),
            Math.round(track.enInfo.danceability * 100),
            Math.round(track.enInfo.loudness),
            Math.round(track.enInfo.valence * 100),
            formatDuration(Math.round(track.enInfo.duration_ms / 1000.0)),
            Math.round(track.enInfo.acousticness * 100),
            Math.round(track.popularity),
            Math.round(track.smart),
            Math.round(track.rnd),
            track
        ]);
    } else {
        table.row.add([
            track.which + 1,
            track.name,
            track.artists[0].name,
            '',
            '', '', '', '', '', '', '', '', '', '',
            track
        ]);
    }
}

function smartOrder(items) {
    let length = items.length;
    let artist_counts = new Proxy({}, { get: (target, name) => name in target ? target[name] : 0 });
    _.each(items, function(item) {
        if (item.track) {
            var track = item.track;
            var artist = track.artists[0].name;
            artist_counts[artist]++;
        }
    });

    let artist_counts_so_far = new Proxy({}, { get: (target, name) => name in target ? target[name] : 0 });
    let out = [];
    let all_items = items.slice();

    while (all_items.length > 0) {
        let best_delta = 1000;
        let best_item = all_items[0];
        _.each(all_items, function(item) {
            if (item.track) {
                var track = item.track;
                let artist = track.artists[0].name;
                let desired_percentage = artist_counts[artist] / length;
                let next_percentage = (artist_counts_so_far[artist] + 1) / (out.length + 1);
                let delta_percentage = Math.abs(next_percentage - desired_percentage);
                if (delta_percentage < best_delta) {
                    best_delta = delta_percentage;
                    best_item = item;
                }
            }
        });
        all_items = all_items.filter(item => item != best_item);
        best_item.track.smart = out.length;
        out.push(best_item);
        artist_counts_so_far[best_item.track.artists[0].name] += 1;
    }
}

function fetchPlaylistTracks(playlist) {
    let all_items = [];

    function fetchLoop(url) {
        var tracks;
        return getSpotifyP(url)
        .then(function(data) {
            var ids = [];
            var aids = [];
            tracks = data.tracks ? data.tracks : data;

            _.each(tracks.items, function(item) {
                all_items.push(item);
                if (item.track) {
                    item.track.which = curPlaylist.tracks.items.length;
                    curPlaylist.tracks.items.push(item);
                    if (!item.is_local) {
                        if (item.track && item.track.id) ids.push(item.track.id);
                        if (!(_.contains(aids, item.track.album.id))) {
                            if (!(item.track.album.id in albumDates)) aids.push(item.track.album.id);
                        }
                    }
                }
            });
            return Promise.all([fetchAllAlbums(aids), fetchAudioFeatures(ids)]);
        })
        .then(function(results) {
            var allAlbums = results[0];
            var trackFeatures = results[1];

            _.each(allAlbums, function(albums) {
                if (!albums || !albums.albums) return;
                _.each(albums.albums, function(album) {
                    if (album != null && 'id' in album) {
                        albumDates[album.id] = album.release_date;
                    }
                });
            });

            if (trackFeatures && 'audio_attributes' in trackFeatures) trackFeatures = trackFeatures['audio_attributes'];
            if (trackFeatures && 'audio_features' in trackFeatures) trackFeatures = trackFeatures['audio_features'];

            var fmap = {};
            _.each(trackFeatures, function(trackFeature) {
                if (trackFeature && trackFeature.id) fmap[trackFeature.id] = trackFeature;
            });

            _.each(tracks.items, function(item) {
                if (item.track && item.track.id) {
                    var tid = item.track.id;
                    item.track.enInfo = (tid in fmap) ? fmap[tid] : {};
                }
            });

            updateTable(tracks.items);

            if (tracks.next) return fetchLoop(tracks.next);

            console.log("tracks loaded");
            smartOrder(all_items);
            clearTable();
            updateTable(all_items);
        });
    }

    var startUrl = (playlist && playlist.tracks && playlist.tracks.href) ? (playlist.tracks.href + (playlist.tracks.href.includes("?") ? "&" : "?") + "limit=50") : ("https://api.spotify.com/v1/playlists/" + playlist.id + "/tracks?limit=50");
    return fetchLoop(startUrl);
}

function fetchSinglePlaylist(playlist) {
    $(".worker").hide();
    $("#single-playlist").show();
    $("#single-playlist-contents").hide();
    $(".spinner2").show();
    $("#song-table tbody").empty();
    window.scrollTo(0,0);
    disableSaveButton();
    songTable.clear();
    resetState();

    curPlaylist = playlist;
    curPlaylist.tracks.items = [];

    $("#playlist-title").text(playlist.name);
    $("#playlist-title").attr('href', playlist.uri);

    info("");

    fetchPlaylistTracks(playlist)
    .then(function() {
        saveState();
        enableSaveButtonWhenNeeded();
    })
    .catch(function(msg) {
        console.log('msg', msg);
        error("Error while loading playlist: " + msg);
    });
}

// ------------------------- Playlist Saving -------------------------

function getSortedUrisFromTable(tracks, table) {
    return _.chain(table.rows({filter:'applied'}).data())
        .select(function(rowdata) { return rowdata[14].uri.startsWith("spotify:track:"); })
        .map(function(rowdata) { return rowdata[14].uri; })
        .value();
}

function savePlaylist(playlist, createNewPlaylist) {
    var tids = getSortedUrisFromTable(playlist.tracks.items, songTable);
    if (tids.length <= 0) {
        error("Cannot save the playlist because there are no tracks left after filtering");
        return;
    }

    disableSaveButton();
    showSaveSpinner(true);

    createOrReusePlaylist(playlist, createNewPlaylist)
    .then(function(playlistToModify) {
        return saveTidsToPlaylist(playlistToModify, tids, true);
    })
    .then(function() {
        saveState();
    })
    .catch(function(msg) {
        error(msg);
    })
    .finally(function() {
        showSaveSpinner(false);
        enableSaveButtonWhenNeeded();
        error("");
    });
}

function saveTidsToPlaylist(playlist, tids, replace) {
    var sliceLength = 100;
    var this_tids = tids.slice(0, sliceLength);
    var remaining = tids.slice(sliceLength);
    var url = "https://api.spotify.com/v1/playlists/" + playlist.id + '/tracks';

    if (replace) {
        return callSpotifyP('PUT', url, { 'uris': this_tids })
        .then(function() {
            if (remaining.length > 0) return saveTidsToPlaylist(playlist, remaining, false);
        })
        .catch(function() {
            return Promise.reject("Trouble saving tracks to the playlist");
        });
    } else {
        return callSpotifyP('POST', url, { 'uris': this_tids })
        .then(function() {
            if (remaining.length > 0) return saveTidsToPlaylist(playlist, remaining, false);
        })
        .catch(function() {
            return Promise.reject("Trouble saving tracks to the playlist");
        });
    }
}

function createPlaylist(owner, name, isPublic) {
    var url = "https://api.spotify.com/v1/users/" + owner + "/playlists";
    var json = { name: name, 'public': isPublic };
    return callSpotifyP('POST', url, json)
        .catch(function() {
            return Promise.reject("Cannot create the new playlist");
        });
}

function getPlaylistState() {
    var firstOrder = [];
    var selectedTableOrder = songTable.order();
    if (selectedTableOrder.length >= 1) firstOrder = _.clone(selectedTableOrder[0]);

    return {
        minBpm: parseInt($('#min-bpm').val(), 10),
        maxBpm: parseInt($('#max-bpm').val(), 10),
        includeDouble: $('#include-double').is(':checked'),
        order: firstOrder,
    };
}

function saveState() {
    savedState = getPlaylistState();
}

function isSavable() {
    return !_.isEqual(savedState, getPlaylistState());
}

function setNeedsSave(state) {
    if (state) {
        $("#save,#saveDropdown").attr('disabled', false).removeClass('btn-warning').addClass('btn-primary');
    } else {
        $("#save,#saveDropdown").attr('disabled', true).addClass('btn-warning').removeClass('btn-primary');
    }
}

function updateSaveButtonState() {
    setNeedsSave(!forceDisableSave && isSavable());
}

function disableSaveButton() {
    forceDisableSave = true;
    updateSaveButtonState();
}

function enableSaveButtonWhenNeeded() {
    forceDisableSave = false;
    updateSaveButtonState();
}

function showSaveSpinner(showSpinner) {
    if (showSpinner) $('#save').addClass('active');
    else $('#save').removeClass('active');
}

function resetState() {
    songTable.order([0, 'asc']);
    $('#min-bpm').val("");
    $('#max-bpm').val("");
    $('#include-double').prop('checked', true);
    saveState();
}

function createOrReusePlaylist(playlist, createNewPlaylist) {
    if (createNewPlaylist) {
        var sortName = getCurSortName();
        return createPlaylist(curUserID, playlist.name + " ordered by " + sortName, playlist.public);
    } else {
        return Promise.resolve(playlist);
    }
}

function initTable() {
    var table = $("#song-table").DataTable({
        paging: false,
        searching: true,
        info: false,
        dom: "t",
        columnDefs: [
            { type: "time-uni", targets: 9 },
        ]
    });

    table.on('order.dt', function() {
        updateSaveButtonState();
    });

    $("#song-table tbody").on('click', 'tr', function () {
        if ($(this).hasClass('selected')) {
            $(this).removeClass('selected');
            stopTrack();
        } else {
            table.$('tr.selected').removeClass('selected');
            $(this).addClass('selected');
            var row = table.row($(this));
            var rowData = row.data();
            var track = rowData[rowData.length - 1];
            playTrack(track);
        }
    });

    return table;
}

$(document).ready(async function() {
    try {
        // init
        songTable = initTable();
        var args = parseArgs();

        // bind login click (no DOMContentLoaded nesting)
        const goBtn = document.getElementById("go");
        console.log("Login button found:", goBtn);

        if (goBtn) {
            goBtn.addEventListener("click", async (event) => {
                event.preventDefault();
                console.log("Login button CLICKED");
                await authorizeUser();
            });
        }

        if ('error' in args && args.error) {
            error("Sorry, I can't read your playlists from Spotify without authorization");
        } else if ('code' in args && args.code) {
            await exchangeCodeForToken(args.code);

            $(".worker").hide();
            fetchCurrentUserProfile(function(user) {
                if (user) {
                    curUserID = user.id;
                    loadPlaylists(user.id);
                } else {
                    error("Trouble getting the user profile");
                }
            });

            // clean URL (remove ?code=...)
            try {
                const u = new URL(window.location.href);
                u.searchParams.delete('code');
                u.searchParams.delete('state');
                window.history.replaceState({}, document.title, u.pathname + u.search + u.hash);
            } catch(e) {}
        }

        $("#save,#dropSave").on('click', function() {
            info("saving ...");
            savePlaylist(curPlaylist, true);
        });

        $("#dropOverwrite").on('click', function() {
            info("overwriting ...");
            savePlaylist(curPlaylist, false);
        });

        $("#pick").on('click', function() {
            showPlaylists();
        });

        $.fn.dataTable.ext.search.push(playlistFilter);
        $('#min-bpm,#max-bpm,#include-double').on('keyup change', function() {
            songTable.draw();
            updateSaveButtonState();
        });
    } catch (e) {
        console.error("FATAL error in document.ready:", e);
        alert("JavaScript error: " + (e && e.message ? e.message : e));
    }
});
</script>

</body>
</html>
